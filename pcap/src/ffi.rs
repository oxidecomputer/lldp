/* automatically generated by rust-bindgen 0.64.0 */

#![allow(nonstandard_style)]
#![allow(dead_code)]

extern "C" {
    pub fn block_on(
        fd: ::core::ffi::c_int,
        delay: ::core::ffi::c_int,
        total: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
pub type suseconds_t = ::core::ffi::c_long;
pub type time_t = ::core::ffi::c_long;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type bpf_u_int32 = u_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_program {
    pub bf_len: u_int,
    pub bf_insns: *mut bpf_insn,
}
#[test]
fn bindgen_test_layout_bpf_program() {
    const UNINIT: ::core::mem::MaybeUninit<bpf_program> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bpf_program>(),
        16usize,
        concat!("Size of: ", stringify!(bpf_program))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_program>(),
        8usize,
        concat!("Alignment of ", stringify!(bpf_program))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bf_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_program),
            "::",
            stringify!(bf_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bf_insns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_program),
            "::",
            stringify!(bf_insns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_insn {
    pub code: u_short,
    pub jt: u_char,
    pub jf: u_char,
    pub k: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    const UNINIT: ::core::mem::MaybeUninit<bpf_insn> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bpf_insn>(),
        8usize,
        concat!("Size of: ", stringify!(bpf_insn))
    );
    assert_eq!(
        ::core::mem::align_of::<bpf_insn>(),
        4usize,
        concat!("Alignment of ", stringify!(bpf_insn))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jt) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(jt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jf) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(jf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_insn),
            "::",
            stringify!(k)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcap {
    _unused: [u8; 0],
}
pub type pcap_t = pcap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcap_pkthdr {
    pub ts: timeval,
    pub caplen: bpf_u_int32,
    pub len: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_pcap_pkthdr() {
    const UNINIT: ::core::mem::MaybeUninit<pcap_pkthdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pcap_pkthdr>(),
        24usize,
        concat!("Size of: ", stringify!(pcap_pkthdr))
    );
    assert_eq!(
        ::core::mem::align_of::<pcap_pkthdr>(),
        8usize,
        concat!("Alignment of ", stringify!(pcap_pkthdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_pkthdr),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).caplen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_pkthdr),
            "::",
            stringify!(caplen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pcap_pkthdr),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn pcap_create(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_set_timeout(arg1: *mut pcap_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_activate(arg1: *mut pcap_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_open_offline(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut pcap_t;
}
extern "C" {
    pub fn pcap_close(arg1: *mut pcap_t);
}
extern "C" {
    pub fn pcap_next_ex(
        arg1: *mut pcap_t,
        arg2: *mut *mut pcap_pkthdr,
        arg3: *mut *const u_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_breakloop(arg1: *mut pcap_t);
}
extern "C" {
    pub fn pcap_setfilter(arg1: *mut pcap_t, arg2: *mut bpf_program) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_setnonblock(
        arg1: *mut pcap_t,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_inject(
        arg1: *mut pcap_t,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_geterr(arg1: *mut pcap_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn pcap_compile(
        arg1: *mut pcap_t,
        arg2: *mut bpf_program,
        arg3: *const ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
        arg5: bpf_u_int32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pcap_get_selectable_fd(arg1: *mut pcap_t) -> ::core::ffi::c_int;
}
